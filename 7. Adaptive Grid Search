import itertools
import numpy as np

def adaptive_grid_search(target_tg, base_models, meta_model, X_scaler, y_scaler, n_iterations=3):
    input_params = ['Lignin (wt%)', 'Ratio', 'Co-polyol type (PTHF)', 
                    'Isocyanate (mmol NCO)', 'Isocyanate type', 
                    'Tin(II) octoate', 'Swelling ratio (%)']
    
    # Initial coarse grid
    grid_points = [
        np.linspace(0, 70, 5),  # 'Lignin (wt%)'
        np.linspace(0.6, 1.4, 5),  # 'Ratio'
        [250, 650, 1000],  # 'Co-polyol type (PTHF)'
        np.linspace(0, 20, 5),  # 'Isocyanate (mmol NCO)'
        [0, 1],  # 'Isocyanate type'
        np.linspace(0, 2, 5),  # 'Tin(II) octoate'
        np.linspace(0, 472, 5)  # 'Swelling ratio (%)'
    ]

    best_params = None
    best_tg_diff = float('inf')

    for _ in range(n_iterations):
        for combo in itertools.product(*grid_points):
            predicted_tg = predict_tg(combo, base_models, meta_model, X_scaler, y_scaler)
            tg_diff = abs(predicted_tg - target_tg)
            
            if tg_diff < best_tg_diff:
                best_tg_diff = tg_diff
                best_params = combo
        
        # Refine the grid around the best parameters
        grid_points = [
            np.linspace(max(0, p - (gp[1]-gp[0])), min(p + (gp[1]-gp[0]), gp[-1]), 5)
            if isinstance(gp, np.ndarray) else gp
            for p, gp in zip(best_params, grid_points)
        ]

    return dict(zip(input_params, best_params)), predict_tg(best_params, base_models, meta_model, X_scaler, y_scaler)

def find_closest_inputs_adaptive_grid(mapped_results, target_tgs, base_models, meta_model, X_scaler, y_scaler):
    closest_inputs = []
    for target_tg in target_tgs:
        best_params, predicted_tg = adaptive_grid_search(target_tg, base_models, meta_model, X_scaler, y_scaler)
        best_params['Target_Tg'] = target_tg
        best_params['Predicted_Tg'] = predicted_tg
        closest_inputs.append(best_params)
    
    return pd.DataFrame(closest_inputs)

# Load the saved models and scalers
run_number = 1  # Change this to the appropriate run number
base_models = joblib.load(f'base_models_run_{run_number}.joblib')
meta_model = joblib.load(f'meta_model_run_{run_number}.joblib')
X_scaler = joblib.load(f'X_scaler_run_{run_number}.joblib')
y_scaler = joblib.load(f'y_scaler_run_{run_number}.joblib')

# Map the target using all feature variations
mapped_results = map_target_batch(base_models, meta_model, X_scaler, y_scaler)

# Save the mapped results
mapped_results.to_csv('mapped_results_tg.csv', index=False)
print("Mapped results saved to 'mapped_results_tg.csv'")

# Define a list of target Tg values
# target_tgs = [20, 30, 40, 50, 60]  # Add your desired target Tg values here
target_tgs = list(range(-20,121))  # Add your desired target Tg values here


# Usage:
closest_inputs = find_closest_inputs_adaptive_grid(mapped_results, target_tgs, base_models, meta_model, X_scaler, y_scaler)
